### 상속 관계 매핑

- 객체의 상속 구조와 데이터베이스의 슈퍼타입 관계를 매핑

#### 조인 전략

- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본키를 받아서 기본키 + 외래키 사용전략
- 객체는 타입으로 구분 할 수 있지만 테이블은 타입의 개념이 없기에 타입을 구분하는 컬럼을 추가
  - 장점 
    - 테이블이 정규화
    - 외래 키 참조 무결성 제약조건 활용
    - 저장 공간을 효울적으로 사용
  - 단점
    - 조회할 때 조인이 많이 사용되므로 성능이 저하
    - 조회 쿼리가 복잡
    - 데이터를 등록할 insert sql문을 두번 실행

#### 단일테이블전략

- 테이블 하나만 사용
  - 장점
    - 조인인 필요없으므로 일반적으로 조회성능이 빠르다
    - 조인 쿼리가 단순하다
  - 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null허용
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다.

#### 구현 클래스마다 테이블 전략

- 구현 글래스마다 테이블 전략을 사용
  - 장점
    - 서브타입을 구분해서 처리할때 효과적이다
    - not null 제약조건을 사용할 수 있다.
  - 단점
    - 여러 자식 텡블을 함께 조회할 때 성능이 느리다
    - 자식 테이블을 통합해서 쿼리하기 어렵다



### @MappedSuperClass

- @mappedSupperClass 는 만들어 지지 않고 이를 상속한 클래스만 db테이블에 만들어짐
  - 즉 엔티티가 아니다.
  - @mappedSupperClass에 정의한 것을 상속받음
  - 부모로 부터 물려받은 매핑 정보를 재정의 하기 위해서는
    - @AttributeOverrides @AttributeOverride
    - 연관 관계 재정의
      - @AssociationOverrides @AssociationOverride



### 식별 관계

- 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본키 + 외래키로 사용



### 비식별 관계

- 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용
  - 외래 키에 null을 허용 유무에 따라 필수적 , 선택적 비식별



### 식별 vs 비식별

- 식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파하기에 자식 테이블의 기본 키 컬럼이 늘어난다.
  - 즉 조인 할때 복잡해지고 기본 키 인덱스가 불필요하게 커진다
- 식별은 비식별에 비해 유연하지 못하다.
- 복합 키는 별도의 복합 키 클래스를 만들어야 한다.
- 장점은 기본키 인덱스를 활용하기 좋다.



### 복합키

- @idclass @embeddedid 2가지 방식 존재

  - @idclass(식별자 클래스)
    - 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야한다.
    - serializable구현
    - 기본 생성자
    - 식별자 클래스는 public
    - equals hashcode 재정의
    - 부모 테이블의 기본 키 컬럼이 복합키 이기에 자식 테이블의 외래 키 또한 복합
  - @embeddedId
    - idclass와 다르게 식별자 클래ㅇ에 기본키를 직접 매핑
    - 그 이외에는 동일 
